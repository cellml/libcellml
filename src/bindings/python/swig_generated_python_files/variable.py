# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _variable
else:
    import _variable

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import libcellml.namedentity
import libcellml.entity
class Variable(libcellml.namedentity.NamedEntity):
    r"""Represents a CellML Variable entity"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _variable.delete_Variable

    def __init__(self, *args):
        _variable.Variable_swiginit(self, _variable.new_Variable(*args))
    InterfaceType_NONE = _variable.Variable_InterfaceType_NONE
    InterfaceType_PRIVATE = _variable.Variable_InterfaceType_PRIVATE
    InterfaceType_PUBLIC = _variable.Variable_InterfaceType_PUBLIC
    InterfaceType_PUBLIC_AND_PRIVATE = _variable.Variable_InterfaceType_PUBLIC_AND_PRIVATE

    @staticmethod
    def addEquivalence(*args):
        r"""
        Adds an equivalence relation between this variable and the given one (both
        objects are updated)
        """
        return _variable.Variable_addEquivalence(*args)

    @staticmethod
    def setEquivalenceMappingId(variable1, variable2, mappingId):
        r"""
        Record the given id as the mapping id for the equivalence defined with the given
        variables.  The variables are commutative. This id appears in the 'map_variables'
        element of the model when serialised.

        To clear an equivalence mapping id set it to the empty string. If the two variables are
        not equivalent the mapping id is not set.
        """
        return _variable.Variable_setEquivalenceMappingId(variable1, variable2, mappingId)

    @staticmethod
    def setEquivalenceConnectionId(variable1, variable2, connectionId):
        r"""
        Record the given id as the connection id for the equivalence defined with the given
        variables.  The variables are commutative. This id appears in the 'connection'
        element of the model when serialised.

        To clear an equivalence connection id set it to the empty string. If the two variables are
        not equivalent the connection id is not set.
        """
        return _variable.Variable_setEquivalenceConnectionId(variable1, variable2, connectionId)

    @staticmethod
    def getEquivalenceMappingId(variable1, variable2):
        r"""Get the mapping id set for the equivalence defined with the given variables."""
        return _variable.Variable_getEquivalenceMappingId(variable1, variable2)

    @staticmethod
    def getEquivalenceConnectionId(variable1, variable2):
        r"""Get the connection id set for the equivalence defined with the given variables."""
        return _variable.Variable_getEquivalenceConnectionId(variable1, variable2)

    @staticmethod
    def removeEquivalence(variable1, variable2):
        r"""
        Removes an equivalence between this variable and the given one (both objects
        are updated).

        Returns `True` on success.
        """
        return _variable.Variable_removeEquivalence(variable1, variable2)

    def removeAllEquivalences(self):
        r"""
        Removes all equivalent variables for this variable (all relevant objects are
        updated).
        """
        return _variable.Variable_removeAllEquivalences(self)

    def equivalentVariableCount(self):
        r"""Returns the number of equivalent variables for this variable."""
        return _variable.Variable_equivalentVariableCount(self)

    def hasEquivalentVariable(self, equivalentVariable):
        r"""
        Tests if the given variable is in this variable's set of equivalent
        variables.
        """
        return _variable.Variable_hasEquivalentVariable(self, equivalentVariable)

    def setUnits(self, *args):
        r"""Sets the units for this variable to the given string (name) or Units object."""
        return _variable.Variable_setUnits(self, *args)

    def getUnits(self):
        r"""Returns the name of the units set for this variable (empty string if none)"""
        return _variable.Variable_getUnits(self)

    def setInitialValue(self, *args):
        r"""
        Sets this variable's initial value, given as a string, number, or variable
        reference.
        """
        return _variable.Variable_setInitialValue(self, *args)

    def getInitialValue(self):
        r"""Returns the string corresponding to the initial value for this variable."""
        return _variable.Variable_getInitialValue(self)

    def setInterfaceType(self, *args):
        r"""
        Sets this variable's interfacetype to the given type specified as string or
        InterfaceType.
        """
        return _variable.Variable_setInterfaceType(self, *args)

    def getInterfaceType(self):
        r"""Returns this variable's interface type as string."""
        return _variable.Variable_getInterfaceType(self)

    def getEquivalentVariable(self, *args):
        r"""Returns the equivalent variable at the given index."""
        return _variable.Variable_getEquivalentVariable(self, *args)

# Register Variable in _variable:
_variable.Variable_swigregister(Variable)

def Variable_addEquivalence(*args):
    r"""
    Adds an equivalence relation between this variable and the given one (both
    objects are updated)
    """
    return _variable.Variable_addEquivalence(*args)

def Variable_setEquivalenceMappingId(variable1, variable2, mappingId):
    r"""
    Record the given id as the mapping id for the equivalence defined with the given
    variables.  The variables are commutative. This id appears in the 'map_variables'
    element of the model when serialised.

    To clear an equivalence mapping id set it to the empty string. If the two variables are
    not equivalent the mapping id is not set.
    """
    return _variable.Variable_setEquivalenceMappingId(variable1, variable2, mappingId)

def Variable_setEquivalenceConnectionId(variable1, variable2, connectionId):
    r"""
    Record the given id as the connection id for the equivalence defined with the given
    variables.  The variables are commutative. This id appears in the 'connection'
    element of the model when serialised.

    To clear an equivalence connection id set it to the empty string. If the two variables are
    not equivalent the connection id is not set.
    """
    return _variable.Variable_setEquivalenceConnectionId(variable1, variable2, connectionId)

def Variable_getEquivalenceMappingId(variable1, variable2):
    r"""Get the mapping id set for the equivalence defined with the given variables."""
    return _variable.Variable_getEquivalenceMappingId(variable1, variable2)

def Variable_getEquivalenceConnectionId(variable1, variable2):
    r"""Get the connection id set for the equivalence defined with the given variables."""
    return _variable.Variable_getEquivalenceConnectionId(variable1, variable2)

def Variable_removeEquivalence(variable1, variable2):
    r"""
    Removes an equivalence between this variable and the given one (both objects
    are updated).

    Returns `True` on success.
    """
    return _variable.Variable_removeEquivalence(variable1, variable2)



